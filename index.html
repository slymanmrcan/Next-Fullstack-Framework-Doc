<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Next.js Full Stack Framework Dokümanı</title>
  <style>
    :root {
      --bg: #0b1220;
      --bg-panel: #0f172a;
      --fg: #e7ecf5;
      --muted: #9fb3c8;
      --accent: #38bdf8;
      --accent-2: #a855f7;
      --border: #1e293b;
      --code: #0a162c;
    }
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      font-family: "Inter", "Segoe UI", system-ui, -apple-system, sans-serif;
      background: radial-gradient(circle at 20% 20%, rgba(56,189,248,0.10), transparent 25%),
                  radial-gradient(circle at 80% 0%, rgba(168,85,247,0.10), transparent 30%),
                  var(--bg);
      color: var(--fg);
      min-height: 100vh;
      display: grid;
      grid-template-columns: 280px 1fr;
    }
    header {
      grid-column: 1 / -1;
      padding: 28px 32px 12px;
      border-bottom: 1px solid var(--border);
      background: linear-gradient(135deg, rgba(56,189,248,0.12), rgba(168,85,247,0.08));
      backdrop-filter: blur(8px);
      text-align: center;
    }
    .header-inner {
      max-width: 960px;
      margin: 0 auto;
    }
    header h1 {
      margin: 0 0 10px;
      font-size: 30px;
      letter-spacing: -0.02em;
    }
    header p {
      margin: 0;
      color: var(--muted);
      line-height: 1.55;
    }
    nav {
      position: sticky;
      top: 0;
      align-self: start;
      height: 100vh;
      padding: 24px 24px 48px;
      border-right: 1px solid var(--border);
      background: rgba(13,17,23,0.85);
      backdrop-filter: blur(10px);
    }
    nav h2 {
      margin: 0 0 12px;
      font-size: 18px;
      color: var(--muted);
      letter-spacing: 0.01em;
    }
    nav a {
      display: block;
      padding: 10px 12px;
      margin-bottom: 6px;
      border-radius: 10px;
      color: var(--fg);
      text-decoration: none;
      border: 1px solid transparent;
      transition: all 0.18s ease;
      font-weight: 600;
    }
    nav a:hover,
    nav a:focus {
      border-color: rgba(34,211,238,0.35);
      background: linear-gradient(135deg, rgba(34,211,238,0.14), rgba(168,85,247,0.09));
      outline: none;
    }
    nav a.active {
      border-color: var(--accent);
      background: rgba(34,211,238,0.12);
      color: #fff;
    }
    main {
      padding: 24px 32px 48px;
      max-width: 1080px;
      width: 100%;
      margin: 0 auto;
    }
    section {
      background: var(--bg-panel);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 24px;
      margin-bottom: 22px;
      box-shadow: 0 25px 80px rgba(0,0,0,0.25);
    }
    h2 {
      margin-top: 0;
      margin-bottom: 12px;
      font-size: 22px;
      letter-spacing: -0.01em;
    }
    p {
      color: var(--muted);
      line-height: 1.6;
      margin-top: 0;
    }
    ul {
      padding-left: 18px;
      color: var(--muted);
      line-height: 1.6;
    }
    .pill {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      margin: 0 8px 8px 0;
      border-radius: 999px;
      background: rgba(34,211,238,0.12);
      color: #c5f6ff;
      border: 1px solid rgba(34,211,238,0.35);
      font-weight: 600;
      font-size: 13px;
    }
    code {
      font-family: "JetBrains Mono", "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;
      background: var(--code);
      padding: 2px 6px;
      border-radius: 6px;
      border: 1px solid var(--border);
    }
    pre {
      background: var(--code);
      padding: 16px;
      border-radius: 12px;
      overflow-x: auto;
      border: 1px solid var(--border);
      color: #cdd7f6;
      line-height: 1.5;
    }
    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 14px;
    }
    .card {
      padding: 16px;
      border-radius: 14px;
      background: linear-gradient(145deg, rgba(34,211,238,0.08), rgba(12, 18, 28, 0.9));
      border: 1px solid var(--border);
    }
    .tagged {
      display: inline-flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-top: 12px;
    }
    .cta {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 10px 14px;
      border-radius: 12px;
      background: linear-gradient(135deg, rgba(34,211,238,0.18), rgba(168,85,247,0.14));
      border: 1px solid rgba(34,211,238,0.35);
      color: #e0f2fe;
      text-decoration: none;
      margin-top: 10px;
      font-weight: 700;
    }
    @media (max-width: 1024px) {
      body {
        grid-template-columns: 1fr;
      }
      nav {
        position: relative;
        height: auto;
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
      }
      nav h2 {
        width: 100%;
      }
      nav a {
        flex: 1 1 200px;
      }
    }
  </style>
</head>
<body>
  <header>
    <div class="header-inner">
      <h1>Next.js Full Stack Framework Dokümanı</h1>
      <p>
        Bu sayfa Next.js ile tam yığın (SSR + API) geliştirme yolunu özetler.
        Prisma ile veri erişimi, API route tasarımı, Swagger/OpenAPI entegrasyonu ve
        gelecekte eklenecek Node.js/Express parçalarını menüden parça parça okuyabilirsiniz.
      </p>
    </div>
  </header>

  <nav aria-label="İçindekiler">
    <h2>Menü</h2>
    <a href="#giris" class="active">Giriş</a>
    <a href="#quickstart">Hızlı Başlangıç</a>
    <a href="#yapilacaklar">Ne Yapılır / Ne Yapılmaz</a>
    <a href="#starter">Starter / Template</a>
    <a href="#compat">Versiyon Uyumu</a>
    <a href="#tools">Faydalı Araçlar</a>
    <a href="#mimari">Mimari Yapı</a>
    <a href="#fs-routing">Dosya Sistemi & Routing</a>
    <a href="#lifecycle">Lifecycle & Middleware</a>
    <a href="#prisma">Prisma & API</a>
    <a href="#orm">Alternatif ORM / Query Builder</a>
    <a href="#auth">Kimlik Doğrulama</a>
    <a href="#endpoint">Endpoint Tanımı</a>
    <a href="#swagger">Swagger / OpenAPI</a>
    <a href="#veritabani">Veritabanı Seçenekleri</a>
    <a href="#veritabani-karsilastirma">Veritabanı Karşılaştırma</a>
    <a href="#uygulama-senaryolari">Uygulama Senaryoları (Yazılım)</a>
    <a href="#docker">Docker Build</a>
    <a href="#deploy">GitHub Pages Yayını</a>
    <a href="#node-express">Node.js / Express (sonraki)</a>
  </nav>

  <main>
    <section id="giris">
      <h2>Giriş</h2>
      <p>
        Next.js, React tabanlı güçlü bir tam yığın çerçevedir. Tek repo içinde hem UI hem API
        barındırır, TypeScript ve dosya tabanlı yönlendirme ile hızlı geliştirme sağlar.
        Aşağıdaki bölümler parçalı ilerlemeniz için hazırlanmıştır.
      </p>
      <div class="tagged">
        <span class="pill">App Router</span>
        <span class="pill">Edge/Node Runtimes</span>
        <span class="pill">Prisma ORM</span>
        <span class="pill">Swagger/OpenAPI</span>
        <span class="pill">PostgreSQL</span>
      </div>
    </section>

    <section id="quickstart">
      <h2>Hızlı Başlangıç</h2>
      <div class="grid">
        <div class="card">
          <strong>1) Projeyi oluştur</strong>
          <ul>
            <li>Gereksinim: Node 18+ (LTS) ve pnpm/npm/yarn</li>
            <li><code>npx create-next-app@latest --typescript --eslint --app --src-dir --import-alias "@/*"</code></li>
            <li>UI: Tailwind eklemek istersen <code>npm i -D tailwindcss postcss autoprefixer</code> + <code>npx tailwindcss init -p</code></li>
          </ul>
        </div>
        <div class="card">
          <strong>2) Env şemasını hazırla</strong>
          <ul>
            <li><code>npm i @t3-oss/env-nextjs zod</code></li>
            <li><code>src/env.mjs</code> içinde zorunlu değişkenleri tanımla</li>
            <li>Örnek: <code>DATABASE_URL</code>, <code>NEXTAUTH_SECRET</code>, <code>APP_URL</code></li>
          </ul>
        </div>
        <div class="card">
          <strong>3) DB & ORM ekle</strong>
          <ul>
            <li>Prisma: <code>npm i prisma @prisma/client</code> + <code>npx prisma init --datasource-provider postgresql</code></li>
            <li><code>src/lib/prisma.ts</code> tekil client örneği oluştur</li>
            <li><code>npx prisma migrate dev --name init</code> ile ilk şema</li>
          </ul>
        </div>
        <div class="card">
          <strong>4) İlk API & UI</strong>
          <ul>
            <li><code>src/app/api/posts/route.ts</code> içine basit GET/POST (örnek yukarıda)</li>
            <li><code>src/app/page.tsx</code> içinde server component, data fetch veya server action</li>
            <li>Client form gerekiyorsa <code>"use client"</code> + Formik/Zustand/TanStack Query kullan</li>
          </ul>
        </div>
        <div class="card">
          <strong>5) Çalıştır & Yayınla</strong>
          <ul>
            <li>Dev: <code>npm run dev</code></li>
            <li>Build: <code>next.config.js</code> → <code>output: "export"</code> (Pages için) ve <code>npm run build</code></li>
            <li>Deploy: <code>out/</code> klasörünü GitHub Pages veya statik host'a ver</li>
          </ul>
        </div>
      </div>
      <p style="margin-top:12px;color:var(--muted);">
        Opsiyonel hızlı ekler: auth (NextAuth.js), middleware ile rate limit/CORS, logger + request-id, Playwright ile 1-2 smoke testi ve CI'da <code>npm run lint && npm run build</code>.
      </p>
    </section>

    <section id="yapilacaklar">
      <h2>Ne Yapılır / Ne Yapılmaz (Asgari Hijyen)</h2>
      <div class="grid">
        <div class="card">
          <strong>Yapılacaklar</strong>
          <ul>
            <li>.env şemasını zorunlu kıl (zod/env-safe)</li>
            <li>API girişlerini schema validate et (zod / yup)</li>
            <li>Prisma Client'ı tekil instance ile paylaş</li>
            <li>Observability: request-id, log context, basic metrics</li>
            <li>CORS & rate limit: middleware ile erken reddet</li>
            <li>Multi-tenant: subdomain/claim bazlı auth + <code>tenantId</code> filter veya RLS; gerekirse schema-per-tenant</li>
            <li>Role/scope: <code>user_roles</code> + policy fonksiyonları (<code>canEditProject</code>) ile kodlanmış kurallar</li>
          </ul>
          <p style="margin:8px 0 0;color:var(--muted);">
            Örnek akış: <code>src/app/(public)/page.tsx</code> (landing), <code>src/app/api/posts/route.ts</code> (CRUD API),
            <code>src/app/dashboard/page.tsx</code> (korumalı panel) hepsi tek repo ve dosya tabanlı routing ile.
            Multi-tenant için <code>src/app/(tenant)/[tenant]/dashboard/page.tsx</code> veya claim bazlı yönlendirme kullan.
          </p>
        </div>
        <div class="card">
          <strong>Yapılmayacaklar</strong>
          <ul>
            <li>Client component içinde direkt env veya secret okumak</li>
            <li>Schema'sız body parse (raw JSON → DB)</li>
            <li>API içinde blocking uzun işler (queue'ya offload et)</li>
            <li>Her istek için yeni PrismaClient açmak</li>
            <li>Edge runtime'da native driver kullanmak (destek yoksa)</li>
            <li>Multi-tenant'ı <code>if (tenant === "...")</code> bloklarıyla dallandırmak; filtreyi unutarak veri sızdırmak</li>
            <li>"Clean architecture" bahanesiyle aşırı soyutlama/katman ekleyip bakım yükü yaratmak</li>
          </ul>
        </div>
      </div>
    </section>

    <section id="starter">
      <h2>Starter / Template Seçenekleri</h2>
      <p>Kurulumda vakit kazandıracak, App Router uyumlu, full-stack odaklı starter örnekleri.</p>
      <div class="grid">
        <div class="card">
          <strong>Next.js Official Starter</strong>
          <ul>
            <li><code>npx create-next-app@latest --typescript --eslint --app --src-dir --import-alias "@/*"</code></li>
            <li>Varsayılan: Tailwind opsiyonel, jest/eslint hazır</li>
            <li>Pages yerine App Router seçili (full-stack için ideal)</li>
            <li>UI eklemek için: <code>npm i tailwindcss@latest postcss autoprefixer</code> ve <code>npx tailwindcss init -p</code></li>
          </ul>
        </div>
        <div class="card">
          <strong>T3-ish Stack (Light)</strong>
          <ul>
            <li>Next + tRPC (veya simple API route) + Prisma + NextAuth</li>
            <li>Tailwind + Shadcn UI eklenebilir</li>
            <li>Edge uyumu için tRPC handler'ı Node runtime'da tut</li>
            <li>Kurulum: <code>npx create-next-app@latest --typescript --eslint --app --src-dir --import-alias "@/*"</code> + <code>npm i @trpc/server @trpc/client @tanstack/react-query @trpc/react-query zod</code></li>
            <li>Prisma/NextAuth ekle: <code>npm i prisma @prisma/client next-auth</code> ve <code>npx prisma init</code></li>
          </ul>
        </div>
        <div class="card">
          <strong>Design-first Docs</strong>
          <ul>
            <li>Statik export için: MDX + Contentlayer / next-mdx-remote</li>
            <li>Swagger UI'yı <code>/docs/swagger</code> route'unda sun</li>
            <li>Pages/CI: <code>output: "export"</code> + <code>next build</code> + GitHub Pages</li>
            <li>Kurulum: <code>npm i next-mdx-remote gray-matter</code> veya <code>npm i contentlayer next-contentlayer</code></li>
          </ul>
        </div>
        <div class="card">
          <strong>Infra-Hazır (CI + Docker)</strong>
          <ul>
            <li>CI: lint + test + <code>next build</code> (<code>output: "export"</code>)</li>
            <li>Docker: multi-stage (deps/builder/runner) + Prisma generate</li>
            <li>Env şeması: <code>zod</code> + <code>dotenv-flow</code> veya <code>@t3-oss/env-nextjs</code></li>
            <li>Kurulum: <code>npm i -D eslint prettier</code> + <code>npm i prisma @prisma/client</code> + Dockerfile'ı ekle</li>
          </ul>
        </div>
      </div>
    </section>

    <section id="compat">
      <h2>Versiyon Uyumu ve Minimum Gereksinimler</h2>
      <p>Yeni Next.js App Router projeleri için önerilen sürümler ve dikkat edilmesi gereken uyumluluklar.</p>
      <div class="grid">
        <div class="card">
          <strong>Framework & Runtime</strong>
          <ul>
            <li>Next.js 14/15 (App Router) + React 18.3+</li>
            <li>Node.js 18.17+ (LTS) veya 20 (Vercel default)</li>
            <li>TypeScript 5.3+ (metadata & server actions uyumu için)</li>
            <li>Static export: <code>next.config.js</code> → <code>output: "export"</code></li>
          </ul>
        </div>
        <div class="card">
          <strong>ORM & DB</strong>
          <ul>
            <li>Prisma 5.x (Node 18+; Data Proxy/Accelerate edge için)</li>
            <li>Drizzle 0.30+ (SQL dialect driver'larını güncel tut)</li>
            <li>TypeORM 0.3.x (Reflect-metadata zorunlu, ES2022 hedefle)</li>
            <li>SQLite için uçta yazma limitlerine dikkat; prod'da Postgres/MySQL</li>
          </ul>
        </div>
        <div class="card">
          <strong>Build & Test</strong>
          <ul>
            <li>Playwright 1.41+ (Node 18+); Jest 29+ veya Vitest 1+</li>
            <li>ESLint 8/9 + Next eslint config; Prettier 3</li>
            <li>CI Node sürümünü <code>package.json</code> <code>engines</code> ile kilitle</li>
            <li>Edge hedefleniyorsa npm paketlerinin ESM/edge desteğini kontrol et</li>
          </ul>
        </div>
        <div class="card">
          <strong>Dev/Deploy Uyum</strong>
          <ul>
            <li>Vercel: Node 18/20, App Router destekli; <code>prisma generate</code> build'de</li>
            <li>Docker: <code>node:20-alpine</code> + <code>npm ci</code> + <code>next build</code></li>
            <li>GitHub Pages: <code>output: "export"</code> + <code>assetPrefix/basePath</code></li>
            <li>Env şeması: <code>zod</code> veya <code>@t3-oss/env-nextjs</code> ile doğrula</li>
          </ul>
        </div>
      </div>
    </section>

    <section id="tools">
      <h2>Faydalı Araçlar (Form, State, Data)</h2>
      <p>Kurulum ve kullanım yerleriyle sık kullanılan yardımcı kütüphaneler.</p>
      <div class="grid">
        <div class="card">
          <strong>Formik + Yup</strong>
          <ul>
            <li>Kurulum: <code>npm i formik yup</code></li>
            <li>Kullanım: Client component içinde <code>useFormik</code> ile form state; <code>validationSchema</code> için Yup</li>
            <li>Örnek: <code>onSubmit</code> içinde server action veya fetch POST</li>
            <li>Not: CSR olduğundan form sayfasını <code>"use client"</code> ile işaretle</li>
          </ul>
        </div>
        <div class="card">
          <strong>Zustand</strong>
          <ul>
            <li>Kurulum: <code>npm i zustand</code></li>
            <li>Kullanım: <code>const useStore = create(...) </code> client bileşenlerde çağır</li>
            <li>Persist için: <code>import { persist } from "zustand/middleware"</code></li>
            <li>Server component'ta doğrudan kullanma; client wrapper oluştur</li>
          </ul>
        </div>
        <div class="card">
          <strong>TanStack Query</strong>
          <ul>
            <li>Kurulum: <code>npm i @tanstack/react-query</code></li>
            <li>Kullanım: <code>QueryClientProvider</code> ile client layout; <code>useQuery</code>/<code>useMutation</code> UI'da</li>
            <li>SSR/Prefetch: Route handler veya server action ile cache'i hydrate et</li>
            <li>Refetch & cache policy'yi App Router <code>revalidate</code> kurallarıyla hizala</li>
          </ul>
        </div>
        <div class="card">
          <strong>Form/State Alternatifleri</strong>
          <ul>
            <li>React Hook Form + Zod: hafif, controlled/ uncontrolled karma kullanım</li>
            <li>Jotai/Valtio: minimal state seçenekleri</li>
            <li>Immer: immutable güncellemeler için <code>npm i immer</code></li>
            <li>Redux Toolkit: kurulum <code>npm i @reduxjs/toolkit react-redux</code>, RTK Query dahil</li>
          </ul>
        </div>
      </div>
      <p style="margin-top:12px;color:var(--muted);">
        Form/state kütüphanelerini client component'lara, veri erişimi/validasyonu ve business logic'i
        server action veya API route'lara koyarak SSR/SEO avantajını koruyun.
      </p>
    </section>

    <section id="mimari">
      <h2>Mimari Yapı</h2>
      <div class="grid">
        <div class="card">
          <strong>src/app</strong>
          <ul>
            <li>UI route'ları (server component + client component)</li>
            <li>API route'ları (route.js / route.ts)</li>
            <li>Segment bazlı layout ve metadata</li>
          </ul>
        </div>
        <div class="card">
          <strong>src/lib</strong>
          <ul>
            <li>Prisma client, yardımcı fonksiyonlar</li>
            <li>DTO/validator (zod/yup) tanımları</li>
            <li>Swagger/OpenAPI generator ayarları</li>
          </ul>
        </div>
        <div class="card">
          <strong>config & devops</strong>
          <ul>
            <li>env şeması (.env, .env.local)</li>
            <li>CI/CD (GitHub Actions) + Pages publish</li>
            <li>Lint, format, test komutları</li>
          </ul>
        </div>
      </div>
      <p style="margin-top:16px;color:var(--muted);">
        Başlangıç komutu (App Router, TypeScript, src dizini, alias):
      </p>
      <pre><code>npx create-next-app@latest --typescript --eslint --app --src-dir --import-alias "@/*"</code></pre>
      <p style="margin-top:8px;color:var(--muted);">
        Dosya sistemi yönlendirme: UI ve API aynı <code>app/</code> altında segment bazlıdır; ayrı router dosyasına gerek yoktur.
      </p>
    </section>

    <section id="fs-routing">
      <h2>Dosya Sistemi & Routing (Next.js App Router)</h2>
      <p>
        Next.js yönlendirme dosya sistemi üzerinden çalışır. Klasörler route segment'i, dosyalar
        içerik/handler'ı temsil eder. SSR/SSG, Streaming ve Route Handlers tek yapıda birleşir.
      </p>
      <div class="grid">
        <div class="card">
          <strong>Temel Dosyalar</strong>
          <ul>
            <li><code>page.tsx</code>: Segment içeriği (server component varsayılan)</li>
            <li><code>layout.tsx</code>: Segment layout'u, children'ları sarmalar</li>
            <li><code>loading.tsx</code>: Suspense fallback (streaming için)</li>
            <li><code>error.tsx</code> / <code>not-found.tsx</code>: Hata/404 sınırları</li>
          </ul>
        </div>
        <div class="card">
          <strong>API & Data</strong>
          <ul>
            <li><code>route.ts</code>: HTTP handler (GET/POST/PUT/DELETE)</li>
            <li><code>Server Actions</code>: <code>"use server"</code> ile form/fetch sonrası kod</li>
            <li>Cache: <code>fetch</code> cache-policy, <code>revalidate</code>, <code>no-store</code></li>
            <li>Edge vs Node runtime: <code>export const runtime = "edge"</code> / <code>"nodejs"</code></li>
          </ul>
        </div>
        <div class="card">
          <strong>Dinamik & Paralel Segmentler</strong>
          <ul>
            <li><code>[id]</code>, <code>[...slug]</code>, <code>[[...slug]]</code> dinamik segmentler</li>
            <li>Paralel route: <code>@modal</code>, <code>@feed</code> gibi adlandırılmış slot'lar</li>
            <li>Intercepting route: <code>(.)</code>, <code>(..)</code>, <code>(..)(..)</code> prefiksleri</li>
          </ul>
        </div>
        <div class="card">
          <strong>Render Pipeline</strong>
          <ul>
            <li>RSC → React Server Components + Client boundary'ler</li>
            <li>SSR/Streaming: <code>loading.tsx</code> ile kısmi render</li>
            <li>Static Export: <code>generateStaticParams</code>, <code>dynamic = "error"</code> / <code>"force-static"</code></li>
            <li>Metadata: <code>export const metadata</code> veya <code>generateMetadata</code></li>
          </ul>
        </div>
      </div>
    </section>

    <section id="lifecycle">
      <h2>Lifecycle & Middleware</h2>
      <p>
        Next.js App Router'da istek akışı: Middleware → Route Handler → Response. Erken aşamada
        kimlik doğrulama, yerelleştirme, CORS, rate limit işlemleri yapılır.
      </p>
      <pre><code>// middleware.ts
import { NextResponse } from "next/server";

export const config = {
  matcher: ["/api/:path*"], // sadece API'lara uygula
};

export async function middleware(request: Request) {
  const origin = request.headers.get("origin") || "";
  if (!origin.includes("example.com")) {
    return NextResponse.json({ error: "forbidden" }, { status: 403 });
  }

  // Basit rate limit örneği (KV/cache entegrasyonu önerilir)
  const response = NextResponse.next();
  response.headers.set("x-app-version", process.env.APP_VERSION || "dev");
  return response;
}</code></pre>
      <p>
        <strong>Lifecycle notları:</strong> Route handler içinde validation → service → repository akışı
        koru. Sunucu component'lerde fetch yerine server action kullanırken cache/prefetch kurallarını
        netleştir. Edge seçilecekse third-party modüllerin uyumunu kontrol et.
      </p>
    </section>

    <section id="prisma">
      <h2>Prisma & API Route Kullanımı</h2>
      <p>
        Prisma, Next.js içinde veritabanına tip güvenli erişim sağlar. Next.js API route'ları
        (App Router altında <code>route.ts</code>) serverless/edge ortamında çalışabilir.
      </p>
      <pre><code>npm install prisma @prisma/client
npx prisma init --datasource-provider postgresql

// src/lib/prisma.ts
import { PrismaClient } from "@prisma/client";

const globalForPrisma = global as unknown as { prisma: PrismaClient | undefined };
export const prisma =
  globalForPrisma.prisma ??
  new PrismaClient({
    log: ["query", "error", "warn"],
  });

if (process.env.NODE_ENV !== "production") globalForPrisma.prisma = prisma;</code></pre>
      <p>
        Ortak <code>prisma</code> örneğini import ederek API route'larda kullanın. Edge runtime
        planlanıyorsa Prisma'nın Data Proxy veya Accelerate desteği değerlendirilmeli.
      </p>
    </section>

    <section id="orm">
      <h2>Alternatif ORM / Query Builder Seçenekleri</h2>
      <p>Prisma dışında Next.js ile yaygın kullanılan, Node runtime uyumlu birkaç seçenek:</p>
      <div class="grid">
        <div class="card">
          <strong>Drizzle ORM</strong>
          <ul>
            <li>SQL-first; edge uyumlu adaptor'lar</li>
            <li>Schema tanımı TypeScript ile yapılır</li>
            <li>CLI: <code>npm i drizzle-orm</code> + <code>drizzle-kit</code></li>
            <li>Migration: <code>drizzle-kit generate</code> → <code>drizzle-kit push</code></li>
          </ul>
        </div>
        <div class="card">
          <strong>TypeORM</strong>
          <ul>
            <li>Decorator tabanlı entity tanımı</li>
            <li>Active Record veya Data Mapper seçilebilir</li>
            <li>CLI: <code>npm i typeorm reflect-metadata</code></li>
            <li>Migration: <code>typeorm migration:generate -n init</code></li>
          </ul>
        </div>
        <div class="card">
          <strong>Sequelize</strong>
          <ul>
            <li>Yıllanmış ve stabil; hook ve model tabanlı</li>
            <li>Dialect desteği geniş (Postgres/MySQL/SQLite)</li>
            <li>CLI: <code>npm i sequelize sequelize-cli</code></li>
            <li>Migration: <code>npx sequelize-cli db:migrate</code></li>
          </ul>
        </div>
        <div class="card">
          <strong>Kysely (Query Builder)</strong>
          <ul>
            <li>Minimal, tip güvenli SQL builder</li>
            <li>ORM yerine hafif abstraction isteyenler için</li>
            <li>CLI yok; migration için <code>kysely-codegen</code> veya <code>umzug</code> kullan</li>
            <li>Edge uyumu: Postgres/Mysql driver'larında TCP kısıtına dikkat</li>
          </ul>
        </div>
      </div>
      <p style="margin-top:12px;color:var(--muted);">
        Prisma tercih edilmiyorsa migration/seed adımlarını CI'da tanımlamayı unutmayın. Edge ortamlarında
        native driver gerektiren ORM'lerde Data Proxy benzeri çözümler veya HTTP tabanlı bağlantılar gerekebilir.
      </p>
    </section>

    <section id="auth">
      <h2>Kimlik Doğrulama & Yetkilendirme</h2>
      <p>Next.js App Router için hafif/ağır seçenekler. Token yaşam döngüsü ve güvenlik notları dahil.</p>
      <div class="grid">
        <div class="card">
          <strong>NextAuth.js (Önerilen)</strong>
          <ul>
            <li>Credential, OAuth (Google/GitHub), Email magic link</li>
            <li>Route Handler uyumlu: <code>auth.ts</code> + server actions</li>
            <li>Session: JWT (stateless) veya DB-backed</li>
            <li>Middleware: <code>auth((req) =&gt; ...)</code> ile guard</li>
          </ul>
        </div>
        <div class="card">
          <strong>JWT (Custom)</strong>
          <ul>
            <li>Header: <code>Authorization: Bearer &lt;token&gt;</code></li>
            <li>İmzalama: HS256 (shared secret) veya RS256 (keypair)</li>
            <li>Claims: <code>sub</code>, <code>exp</code>, <code>scope</code>, <code>tenant</code></li>
            <li>Rotation + refresh token; <code>jti</code> ile blacklist desteği</li>
          </ul>
        </div>
        <div class="card">
          <strong>Session Cookie</strong>
          <ul>
            <li>HttpOnly, Secure, SameSite=Lax/Strict; kısa TTL</li>
            <li>CSRF koruması: çift cookie (token + header)</li>
            <li>Stateful store: Redis veya DB</li>
            <li>Edge uyumu için cookie boyutunu küçük tut</li>
          </ul>
        </div>
        <div class="card">
          <strong>AuthZ (Yetki)</strong>
          <ul>
            <li>Role/Scope tablosu: <code>user_roles</code>, <code>permissions</code></li>
            <li>Route guard: middleware'de role check; handler içinde iş kuralı</li>
            <li>Domain-driven: policy fonksiyonları (<code>canEditPost(user, post)</code>)</li>
            <li>Audit log: kim, ne zaman, hangi kaynağa erişti</li>
          </ul>
        </div>
      </div>
      <pre><code>// middleware.ts (auth guard örneği)
import { NextResponse } from "next/server";
import { verifyJwt } from "@/lib/auth";

export const config = { matcher: ["/api/secure/:path*"] };

export async function middleware(request: Request) {
  const token = request.headers.get("authorization")?.replace("Bearer ", "");
  if (!token) return NextResponse.json({ error: "unauthorized" }, { status: 401 });

  const payload = await verifyJwt(token); // exp, scope kontrolü
  if (!payload) return NextResponse.json({ error: "forbidden" }, { status: 403 });

  const res = NextResponse.next();
  res.headers.set("x-user-id", payload.sub || "");
  return res;
}</code></pre>
    </section>

    <section id="endpoint">
      <h2>Endpoint Tanımı (App Router)</h2>
      <p>Basit CRUD için <code>POST</code> ve <code>GET</code> örneği:</p>
      <pre><code>// src/app/api/posts/route.ts
import { NextResponse } from "next/server";
import { prisma } from "@/lib/prisma";

export async function GET() {
  const posts = await prisma.post.findMany({ orderBy: { createdAt: "desc" } });
  return NextResponse.json(posts);
}

export async function POST(request: Request) {
  const body = await request.json();
  const post = await prisma.post.create({ data: body });
  return NextResponse.json(post, { status: 201 });
}</code></pre>
      <p>
        Daha sıkı doğrulama için <code>zod</code> ile payload kontrolü,
        <code>NextResponse</code> hata kodları ve rate limit eklentisi önerilir.
      </p>
    </section>

    <section id="swagger">
      <h2>Swagger / OpenAPI Entegrasyonu</h2>
      <p>
        OpenAPI şemasını programatik üreterek Swagger UI ile sunabilirsiniz.
        App Router altında statik JSON endpoint + Swagger UI route örneği:
      </p>
      <pre><code>// src/app/api/openapi/route.ts
import { NextResponse } from "next/server";
import { openApiSchema } from "@/lib/openapi"; // zod-to-openapi vb.

export async function GET() {
  return NextResponse.json(openApiSchema, {
    headers: { "Cache-Control": "public, max-age=300" },
  });
}

// src/app/docs/swagger/page.tsx
import SwaggerUI from "swagger-ui-react";
import "swagger-ui-react/swagger-ui.css";

export default function SwaggerPage() {
  return &lt;SwaggerUI url="/api/openapi" docExpansion="list" />;
}</code></pre>
      <p>
        GitHub Pages statik olduğu için Next.js yönlendirmesi veya standalone build
        ile barındırma tercih edilmeli. Eğer sadece dokümantasyon yayınlanacaksa
        Swagger UI'yı statik HTML olarak da ekleyebilirsiniz.
      </p>
    </section>

    <section id="veritabani">
      <h2>Veritabanı Seçenekleri</h2>
      <p>
        Farklı ortamlara göre hızlı bağlantı önerileri. Her DB'nin dili/kökeni, bağlantı örneği ve Next.js/edge uyumu için kısa notlar.
      </p>
      <div class="grid">
        <div class="card">
          <strong>PostgreSQL (varsayılan)</strong>
          <ul>
            <li>C ile yazılmış, açık kaynak; geniş eklenti ve JSONB desteği</li>
            <li>Prod: pgbouncer (transaction mode) + Prisma Accelerate/Data Proxy</li>
            <li>Local DSN: <code>postgresql://user:pass@localhost:5432/db</code></li>
            <li>Test: <code>dotenv -e .env.test prisma migrate deploy</code></li>
          </ul>
        </div>
        <div class="card">
          <strong>MySQL</strong>
          <ul>
            <li>C/C++ ile, Oracle tarafından geliştirilen popüler RDBMS</li>
            <li>DSN: <code>mysql://user:pass@localhost:3306/db</code></li>
            <li>Edge: Data Proxy tercih et; native TCP driver edge'de çalışmaz</li>
            <li>Migration: <code>npx prisma migrate dev --create-only</code></li>
          </ul>
        </div>
        <div class="card">
          <strong>MariaDB</strong>
          <ul>
            <li>MySQL fork'u, tamamen açık kaynak</li>
            <li>DSN: <code>mysql://user:pass@localhost:3306/db</code> (aynı format)</li>
            <li>SSL için: <code>?sslaccept=strict</code> ekle</li>
            <li>Prisma için MariaDB provider'ını kullanmayı unutma</li>
          </ul>
        </div>
        <div class="card">
          <strong>Microsoft SQL Server (MSSQL)</strong>
          <ul>
            <li>C++ ile Microsoft geliştirmesi; Windows/Linux'ta çalışır</li>
            <li>DSN: <code>sqlserver://user:pass@localhost:1433;database=db</code></li>
            <li>Driver: Prisma MSSQL provider veya Node <code>tedious</code></li>
            <li>Azure SQL için bağlantıda <code>encrypt=true</code> kullan</li>
          </ul>
        </div>
        <div class="card">
          <strong>Oracle Database</strong>
          <ul>
            <li>C ile yazılmış, kurumsal lisanslı</li>
            <li>DSN: <code>oracle://user:pass@host:1521/service</code> (Instant Client gerekir)</li>
            <li>Node için <code>oracledb</code> paketi; edge uyumlu değildir</li>
            <li>Prisma: Oracle preview provider'ı takip edilmeli</li>
          </ul>
        </div>
        <div class="card">
          <strong>SQLite</strong>
          <ul>
            <li>Hafif kullanım, prototip veya uç noktalarda cache için</li>
            <li>Serverless'ta dosya tabanlı olduğu için yazma yükü sınırlı</li>
            <li>CI'da hızlı: <code>DATABASE_URL="file:./dev.db"</code></li>
          </ul>
        </div>
        <div class="card">
          <strong>MongoDB</strong>
          <ul>
            <li>C++ ile yazılmış doküman veritabanı; JSON benzeri BSON</li>
            <li>Prisma provider: <code>mongodb</code> (schema zorunlu değil)</li>
            <li>Edge uyumu için Data Proxy; aksi halde TCP kısıtı</li>
            <li>Schema olmayan dokümanlar için DTO katmanı şart</li>
          </ul>
        </div>
      </div>
    </section>

    <section id="veritabani-karsilastirma">
      <h2>Veritabanı Karşılaştırma (Mühendislik Özeti)</h2>
      <p>PostgreSQL, MSSQL, Oracle ve MySQL/MariaDB için dil, MVCC/locking, ekosistem ve Next.js/Node uyumu.</p>
      <div class="grid">
        <div class="card">
          <strong>PostgreSQL</strong>
          <ul>
            <li>Dil: C; SQL: ANSI + PL/pgSQL, PL/Java/Python destekli</li>
            <li>MVCC: gerçek MVCC; vacuum gerektirir; yüksek concurrency iyi</li>
            <li>Öne çıkan: JSONB, extension (PostGIS, pgvector), logical replication</li>
            <li>Node/Next: <code>pg</code>/Prisma olgun; edge için Accelerate/Data Proxy</li>
          </ul>
        </div>
        <div class="card">
          <strong>Microsoft SQL Server (MSSQL)</strong>
          <ul>
            <li>Dil: C++; SQL: T-SQL (procedural, window functions zengin)</li>
            <li>MVCC: varsayılan lock; <code>READ_COMMITTED_SNAPSHOT</code> ile row-versioning</li>
            <li>Öne çıkan: Columnstore index, SSIS/SSRS/SSAS entegrasyonu, Always On</li>
            <li>Node/Next: <code>tedious</code>/<code>mssql</code> driver; edge yok, Data Proxy yok</li>
          </ul>
        </div>
        <div class="card">
          <strong>Oracle Database</strong>
          <ul>
            <li>Dil: C; SQL: PL/SQL (paket, trigger, advanced cursor)</li>
            <li>MVCC: undo segment tabanlı; uzun transaction toleransı yüksek</li>
            <li>Öne çıkan: RAC/Data Guard, partitioning, flashback, parallel query</li>
            <li>Node/Next: <code>oracledb</code> (Instant Client), edge uyumsuz; Prisma Oracle preview</li>
          </ul>
        </div>
        <div class="card">
          <strong>MySQL / MariaDB</strong>
          <ul>
            <li>Dil: C/C++; SQL: MySQL dialect (procedure, trigger, event, limited window funcs)</li>
            <li>MVCC: InnoDB row-versioning; metadata lock'lara dikkat</li>
            <li>Öne çıkan: replikasyon kolay, JSON alan basit; MariaDB bazı fonksiyonlarda ayrışıyor</li>
            <li>Node/Next: <code>mysql2</code>/Prisma; edge yok, Data Proxy (MySQL) önerilir</li>
          </ul>
        </div>
      </div>
      <p style="margin-top:12px;color:var(--muted);">
        Kısa seçim rehberi: Web/SaaS için PostgreSQL (özgür, güçlü JSONB, community), MS stack entegrasyonu ve T-SQL araçları için MSSQL, mevcut Oracle lisansı/RAC ihtiyacı için Oracle, hafif/ucuz barındırma veya MySQL uyumlu managed servisler için MySQL/MariaDB.
      </p>
      <div class="card" style="margin-top:12px;">
        <strong>Dil/Dialekt Odaklı Test Case Örnekleri</strong>
        <ul>
          <li><em>JSON işleme (PostgreSQL, PL/pgSQL):</em> JSONB index + <code>SELECT data->>'event' FROM logs WHERE data @> '{"userId":123}'</code>; performans ve plan kontrolü.</li>
          <li><em>Pipelined ETL (MSSQL, T-SQL):</em> <code>OPENJSON</code> ile staging tablosu doldur, Columnstore index ile sorgu süresini ölç; lock wait monitörü.</li>
          <li><em>Partition + parallel query (Oracle, PL/SQL):</em> <code>PARTITION BY RANGE</code> tablo, <code>PARALLEL</code> hint ile raportlama; undo/flashback etkisini izle.</li>
          <li><em>Online schema change (MySQL/MariaDB, MySQL dialect):</em> <code>ALTER TABLE ... ALGORITHM=INPLACE, LOCK=NONE</code> testi; metadata lock ve replika gecikmesini ölç.</li>
          <li><em>Logical replication / CDC (PostgreSQL veya MSSQL):</em> PG için <code>pgoutput</code> veya wal2json, MSSQL için CDC ile snapshot tutarlılığını ve lag metriğini doğrula.</li>
        </ul>
      </div>
    </section>

    <section id="uygulama-senaryolari">
      <h2>Uygulama Senaryoları (Yazılım)</h2>
      <p>Framework/driver/cache/queue tercihleri ile uygulama odaklı karar rehberi.</p>
      <div class="grid">
        <div class="card">
          <strong>Hangi İşte Hangisi Tercih Edilir?</strong>
          <ul>
            <li><em>SaaS ürün + event log + JSON payload yoğun:</em> PostgreSQL (JSONB + GIN), Prisma, Redis cache; edge gerekirse Accelerate/Data Proxy.</li>
            <li><em>Microsoft ekosistemi + PowerBI/SSRS raporlama:</em> MSSQL (T-SQL, Columnstore), <code>mssql</code> driver; SSIS/SSRS/PowerBI entegrasyonu.</li>
            <li><em>Kurumsal core banking/telekom + RAC/partitioning ihtiyacı:</em> Oracle (PL/SQL, RAC/DataGuard, flashback), <code>oracledb</code>; lisans/Instant Client planı şart.</li>
            <li><em>Hızlı büyüyen, yazma/okuma dengeli marketplace:</em> PostgreSQL (MVCC, logical replication) + Citus opsiyonu; pgbouncer, Redis cache, read replica.</li>
            <li><em>Düşük maliyetli hosting / LAMP uyumu:</em> MySQL veya MariaDB (InnoDB), <code>mysql2</code>/Prisma; ProxySQL veya RDS read replica.</li>
          </ul>
        </div>
        <div class="card">
          <strong>Uygulama Odaklı 5 Senaryo (Detaylı)</strong>
          <ul>
            <li><em>Instagram benzeri feed, 1.000 eşzamanlı:</em> PostgreSQL + read replicas, JSONB/GIN denormalize feed; cache (Redis) + logical replication; pgbouncer ile 50-100 connection.</li>
            <li><em>Finans/çekirdek işlem (ACID + audit):</em> Oracle veya PostgreSQL; Oracle RAC/DataGuard + PL/SQL audit, PostgreSQL WAL archive + PITR, serializable isolation.</li>
            <li><em>ETL + analitik rapor:</em> MSSQL (OPENJSON + Columnstore) veya PostgreSQL + Citus/Timescale; staging → transform → fact/dim; SSIS/PowerBI için MSSQL avantajlı.</li>
            <li><em>Multi-tenant B2B SaaS:</em> PostgreSQL RLS + <code>tenant_id</code> filter veya MSSQL security policy; Citus veya MSSQL elastic pool ile sharding; migration/seed tenant-aware.</li>
            <li><em>Düşük bütçe CRUD + paylaşımlı hosting:</em> MySQL/MariaDB managed; InnoDB, BTREE index; online schema change <code>ALGORITHM=INPLACE</code>; driver <code>mysql2</code> + Prisma.</li>
          </ul>
        </div>
      </div>
    </section>

    <section id="docker">
      <h2>Docker Build (Prisma ve Alternatif ORM'lerle)</h2>
      <p>Multi-stage build ile Prisma gibi generate adımı olan ORM'ler için örnek. Diesel/TypeORM/Drizzle gibi araçlar da benzer yapıyı kullanabilir.</p>
      <pre><code># Dockerfile
FROM node:20-alpine AS deps
WORKDIR /app
RUN apk add --no-cache libc6-compat openssl
COPY package*.json ./
RUN npm ci

FROM node:20-alpine AS builder
WORKDIR /app
RUN apk add --no-cache libc6-compat openssl
COPY --from=deps /app/node_modules ./node_modules
COPY . .
# Prisma özel: generate (schema.prisma okur) ve gerekiyorsa migrate
RUN npx prisma generate
# Eğer build sırasında DB erişimi yoksa migrate'i CI'da çalıştırın
RUN npm run build

FROM node:20-alpine AS runner
WORKDIR /app
ENV NODE_ENV=production
RUN addgroup -g 1001 -S nodejs && adduser -S nextjs -u 1001
COPY --from=builder /app/next.config.js ./next.config.js
COPY --from=builder /app/public ./public
COPY --from=builder /app/.next/standalone ./
COPY --from=builder /app/.next/static ./.next/static
COPY --from=builder /app/node_modules/.prisma ./node_modules/.prisma
USER nextjs
EXPOSE 3000
CMD ["node", "server.js"]</code></pre>
      <p>
        <strong>Notlar:</strong> Standalone çıktıda <code>server.js</code> Next.js tarafından üretilir.
        Prisma için <code>.prisma</code> klasörünü de kopyalamak gerekir. Drizzle/TypeORM gibi
        alternatiflerde generate adımlarını builder aşamasında çalıştırın, runtime'da sadece gerekli
        dosyaları kopyalayın.
      </p>
    </section>

    <section id="deploy">
      <h2>GitHub Pages Yayını</h2>
      <ul>
        <li><code>next.config.js</code> içinde <code>output: "export"</code> ayarlayıp <code>next build</code> çıktısı olan <code>out/</code> klasörünü Pages'a verin.</li>
        <li><code>assetPrefix</code> ve <code>basePath</code> ayarlarını repo adına göre güncelleyin.</li>
        <li>CI adımı: <code>npm run build</code> (<code>output: "export"</code>) sonrası <code>out</code> klasörünü dağıtın.</li>
        <li>API çağrıları gerekiyorsa: Vercel/Render gibi dinamik ortamı Pages ile birlikte düşünün.</li>
      </ul>
      <a class="cta" href="https://nextjs.org/docs/pages/building-your-application/deploying/static-exports" target="_blank" rel="noreferrer">
        Next.js Static Export Rehberi
      </a>
    </section>

    <section id="node-express">
      <h2>Node.js / Express (Planlanan)</h2>
      <p>
        İleride aynı dokümana Express.js bölümü eklemek için menüde yer ayrıldı.
        Plan: ortak DTO/şema paylaşımı, OpenAPI uyumu, Next.js ile shared component/utility
        katmanı ve Swagger UI'nın her iki servis için aynı şema kaynağından üretilmesi.
      </p>
      <ul>
        <li>Ortak <code>packages/validators</code> veya <code>src/lib/validation</code></li>
        <li>Express için <code>express-openapi-validator</code> entegrasyonu</li>
        <li>API versiyonlama: <code>/api/v1</code>, <code>/api/v2</code></li>
      </ul>
    </section>
  </main>

  <script>
    const links = Array.from(document.querySelectorAll("nav a"));
    const sections = links.map(link => document.querySelector(link.getAttribute("href")));

    const observer = new IntersectionObserver(
      entries => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            links.forEach(link => link.classList.toggle("active", link.getAttribute("href") === "#" + entry.target.id));
          }
        });
      },
      { rootMargin: "-40% 0px -50% 0px", threshold: 0.4 }
    );

    sections.forEach(section => section && observer.observe(section));
  </script>
</body>
</html>
